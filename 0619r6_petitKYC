
//Rxãƒ¦ãƒ¼ã‚¶ãƒã‚§ãƒƒã‚¯UCéƒ¨ã€ãƒ—ãƒpetitKYCéƒ¨
    //æœªè¨­å®šæ™‚SBTçŠ¶æ…‹ã€‚EOA/CA
    mapping(address => bool) public userToUcRes;//UC-petitKYCãƒ•ãƒ©ã‚°ã‚ªãƒ³ã€‚
    //UCç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥
    mapping(address => bytes32) public userToUcPwdHash;



    //Ucãƒãƒ£ãƒ¬ãƒ³ã‚¸ã€€ã‚·ãƒ¼ã‚¯ã‚¨ãƒ³ã‚¹sq1A
    function s_sq1A_rxLimit_Uc_Cha_ByOwner(address account ,
                                            string memory mailMes/*åˆã¯Pwdãƒãƒƒã‚·ãƒ¥å€¤ç›´æ¥*/,
                                            string memory ownerPwd)
    onlyPwdOwnerOne(ownerPwd) 
    public
    returns (address account_ ,bytes32 hash_)
    {
        //ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯ãƒ¬ã‚³ãƒ¼ãƒ‰ã—ãªã„ã€‚å…ƒã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒãƒƒã‚·ãƒ¥å€¤ã¯è¨˜éŒ²ã™ã‚‹ã€‚
        userToUcPwdHash[account]=sha256(abi.encodePacked(mailMes));

        //ãƒ¬ã‚³ãƒ¼ãƒ‰ã—ãªã„ã‘ã©ãƒãƒƒã‚·ãƒ¥ã‚’ç…§åˆã™ã‚‹ãŸã‚Chaç”Ÿæˆã€‚Kcã¯é•·ã‚ã®é›»å­ç½²åä»˜ä¸æ¸ˆã¿ãƒ¡ãƒ¼ãƒ«æ–‡ã§ã‚‚ã„ã„ã€‚
        return ( account  ,  userToUcPwdHash[account]);

    }   
        /*ğŸ“¨
            owner post
            include:[account,mailMes]

            (email/paper mail hagaki) mes mail to user.
            *crypted email / E2E SNS-SIGNAL? *SMS is ok too. 
            *paper postğŸ£ğŸ“® is more better for "check if is user real human?" 
        ğŸ“¨*/

    //Ucãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€ã‚·ãƒ¼ã‚¯ã‚¨ãƒ³ã‚¹sq1B
    //sq1A->sq1Bã™ã‚‹ã“ã¨
    //ãƒ¬ã‚¹ãƒãƒ³ã‚¹OKãªã‚‰é€é‡‘å—å–åˆ¶é™è§£é™¤
    //ã‚µãƒ¼ãƒ“ã‚¹ã«ã‚ˆã£ã¦ã¯æœ¬äººé™å®šéƒµä¾¿ã§é€ã‚Œã‚‹ã¨ã‚ˆã„ã€‚    
    function s_sq1B_rxLimit_Uc_Res_ByUser (address account_, string memory mes_, string memory nowPwd) 
    isPwdHashUser(nowPwd) //ãƒ¦ãƒ¼ã‚¶ãƒ‘ã‚¹ä»˜ã§ãƒ¦ãƒ¼ã‚¶èªè¨¼
    public
    returns (bool)
    {
        //å…¥åŠ›è€…ã®EOAã¨æ¤œè¨¼ç”¨EOAã‚·ãƒ¼ãƒ‰æ¯”è¼ƒ
        require(msg.sender == account_ , "err:msg.sender != account_");

        //å…¥åŠ›è€…ã®mesã¨æ¤œè¨¼ç”¨mesHashã®æ¯”è¼ƒ
        require(userToUcPwdHash[msg.sender] == sha256(abi.encodePacked(mes_)),"err");

        userToUcRes[msg.sender]=true;//UC-KYCçµæœãƒ•ãƒ©ã‚°ã‚ªãƒ³ã€‚

        return true;

        //userToUcRes[msg.sender]=trueã¯å—å–ã‚’è¡Œã†ã“ã¨å¯èƒ½ã«ã€‚
    }   

            //ãƒ¦ãƒ¼ã‚¶ã«å¯¾ã™ã‚‹ãƒ¡ãƒ¢éƒ¨
            mapping(address => bytes32) public userToOwnerLog;//ãƒ¦ãƒ¼ã‚¶ãƒ¡ãƒ¢ã‚„ãƒ¦ãƒ¼ã‚¶èªè¨¼ç”¨ã‚ªãƒ¼ãƒŠãƒ¼æ›¸ãè¾¼ã¿éƒ¨ã€‚èªè¨¼ç”¨ã§ãªãã¦ã‚‚ã„ã„ã€‚ãƒ¡ãƒ¢éƒ¨ã€‚ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚ªãƒ¼ãƒŠãƒ¼å´ã¨ãƒ¦ãƒ¼ã‚¶ã§ã®é€šä¿¡æ™‚é€æ˜æ€§ã®ç‚ºãƒ‘ãƒ–ãƒªãƒƒã‚¯
            function set_userToOwnerLog_By_OwnerOne(address account , bytes32 logbytes32 , string memory pwd) 
            public
            onlyPwdOwnerOne(pwd) 
            {
                userToOwnerLog[account]= logbytes32;
            }

            //ã“ã“ã§ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥è¨˜éŒ²ã—ã¦ã‹ã‚‰ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒ¦ãƒ¼ã‚¶ã«éƒµé€ã‚„ãƒ¡ãƒ¼ãƒ«ã§å±Šã‘ã¦èªè¨¼ã—ã€èªè¨¼é€šã£ãŸã‚‰ãƒŸãƒ³ãƒˆã™ã‚‹ã€‚
            //ãã†ã§ãªã‘ã‚Œã°è³¼å…¥ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã›ã‚‹ã“ã¨ã‚‚â€¦
            //ã¾ãŸè¦æ³¨æ„ãªEOAã‚’ã“ã®é–¢æ•°ã§è¨˜éŒ²ã—ã¦ãŠã„ã¦è‡ªç¤¾ã‚·ã‚¹ãƒ†ãƒ ã§ç”¨ã„ã‚‹ã“ã¨ã‚‚ã€‚

//ãƒ¦ãƒ¼ã‚¶ã‹ã‚‰ã®é€é‡‘é™åº¦é¡è¨­å®šéƒ¨=====================================================================
    //1TXã‚ãŸã‚Šã®é€é‡‘Txcé™åº¦éƒ¨ã€ãƒ¦ãƒ¼ã‚¶å®šç¾©ãƒ•ãƒ©ã‚°
    mapping(address => uint256) private userToTxLimit_ByUser;

    //å…¨é‡è»¢é€è¨­å®šå¯èƒ½é–¢æ•°
    function s_txLimit_ByUser_PwdHash(uint256 amount , string memory nowPwd)
    isPwdHashUser(nowPwd)
    public
    {
        //é€é‡‘é¡ã®åˆ¶é™ãªã—
        userToTxLimit_ByUser[msg.sender]=amount;//0ã‹ã‚‰2**256-1
    }    
